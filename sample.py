
import requests
import os
from flask import Flask, request,jsonify
from slackclient import SlackClient
app = Flask(__name__)
 
@app.route("/bpn",methods=['POST','GET'])
def hello():
	return "getInputs <- function() { inputs <- c() inputs = c(inputs, 1) itr = 1 for(i in names(wine)) { if(itr != 14) { value = wine[itr][1,] inputs = c(inputs,value) itr = itr + 1 } } return(inputs) } normalizeInput <- function(inputs) { print(inputs) for(i in 2:length(inputs)) { norm = max(wine[i-1]) - min(wine[i-1]) inputs[i] = inputs[i][[1]]/(norm) } return(inputs) } generateVMatrix <- function(l,m) { vMatrix = matrix(0,l,m) for(i in 1:l) { for(j in 1:m) { vMatrix[i,j] = runif(1,-1.0,1.0) } } return(vMatrix) } generateWMatrix <- function(m,n) { wMatrix = matrix(0,m,n) for(i in 1:m) { for(j in 1:n) { wMatrix[i,j] = runif(1,-1.0,1.0) } } return(wMatrix) } populateOHMatrix <- function(m,ih) { oh = matrix(0,m,1) for(i in 1:m) { oh[i,1] = 1/(1+exp(-1*ih[i,1])) } return(oh) } populateOOMatrix <- function(n,io) { oo = matrix(0,n,1) for(i in 1:n) { oo[i,1] = 1/(1+exp(-1*io[i,1])) } return(oo) } inputs = getInputs() inputs = normalizeInput(inputs) l = length(inputs) m = 20 n = 3 v = generateVMatrix(l,m) w = generateWMatrix(m,n) deltaV = matrix(0,m,n) deltaW = matrix(0,m,n) oi = matrix(inputs) ii = matrix(inputs) ih = t(v) %*% oi oh = populateOHMatrix(m,ih) io = t(w) %*% oh oo = populateOOMatrix(n,io) oo t = wine[14][1,] d = (t-oo) * (oo) * (1-oo) d y = oh %*% t(d) y alpha = 0.5 nu = 0.6 deltaW = (alpha*deltaW)+(nu*y) deltaW e = w %*% d dstar = e*oh*(1-oh) dstar x = oi %*% t(dstar) deltaV = (alpha*v) + (nu*x) v = v + deltaV w = w + deltaW"

@app.route("/rbf",methods=['POST','GET'])
def hellorbf():
  return "# no of neurons in hidden layers m = 4 data = iris data = data[1:150,1:4] # no of nu.... m <= u >= input size u = iris[sample(150,size = m),1:4] weights = sample(x = c(1,-1),replace=TRUE,size = 4) maximumDistance = function(){ distance = list() for(i in 1:m) { for(j in 1:i){ d = sum((u[i,]-u[j,])^2) distance = c(distance,d) } } print(max(unlist(distance))) return(max(unlist(distance))) } findRBF = function(max_dist){ phi = vector('list',length = length(u)) print(nrow(data)) for(i in 1:length(u)){ for(j in 1:nrow(data)){ ans = exp(- ( (m/max_dist)* (sum(data[j,]-u[i,]) ^ 2 ) ) ) phi[[i]] = c(phi[[i]],ans) } } print(phi) return(phi) } max_dist = maximumDistance() phi_value = findRBF(max_dist) plot(x = phi_value[[3]],y = phi_value[[4]],xlab = '3rd iris',ylab = '4th iris',main = 'for iris') updated_weight = vector('list',length = m) output = list() for(i in 1:m){ a = phi_value[[i]] * weights[i] updated_weight[[i]] = c(updated_weight[[i]],a) } sum_weight = updated_weight[[1]] + updated_weight[[2]] + updated_weight[[3]] + updated_weight[[4]] for(i in 1:length(sum_weight)){ if(sum_weight[i] < -1){ output = c(output,0) } else{ output = c(output,1) } }"

@app.route("/sofm",methods=['POST','GET'])
def hellosofm():
  return "generate_training_samples <- function(n,l){ inp <- list() i <- 1 while(i <= n){ random_inp <- sample(c(0,1),isze = l,replace = TRUE) for(j in 1:length(inp)){ if(length(inp) != 0 && all(inp[[j]] == random_inp)) next } inp[[i]] <- random_inp i <- i + 1 } return(inp) } generate_weights <- function(n,m){ w <- matrix(nrow = n,ncol = m) for(i in 1:n){ for(j in 1:m){ w[i,j] <- round(runif(1,0,1),1) } } return(t(w)) } update_weights <- function(w,inp,lr){ new_w_i <- w + lr*(inp-w) return(new_w_i) } find_distance <- function(w,inp){ return(sum((inp-w)^2)) } find_row <- function(ind,dim){ return(ceiling(ind/dim)) } find_col <- function(ind,dim){ return(ind - (find_row(ind,dim)-1)*dim) } find_neighbours_within_radius <- function(ind,radius,dim){ top_neighbours <- ind-(dim*radius) if(top_neighbours<0) top_neighbours <- find_col(ind,dim) left_neighbours <- ind-radius if(find_row(left_neighbours,dim) != find_row(ind,dim)) left_neighbours <- (find_row(ind,dim)-1)*dim + 1 right_neighbours <- ind+radius if(find_row(right_neighbours,dim)!= find_row(ind,dim)) right_neighbours <- (find_row(ind,dim))*dim bottom_neighbours <- ind+(dim*radius) if(bottom_neighbours>100) bottom_neighbours <- (dim-1)*dim + find_col(ind,dim) neighbours <- vector(\"list\",length=0) neighbours <- append(neighbours,c(top_neighbours,left_neighbours,right_neighbours,bottom_neighbours)) return(neighbours) } n <- 10 # no of inputs veclength_n <- 4 # length of each input vector m <- 100 # no of outputs mrow <- 10 # make output as square matrix mcol <- 10 outputs <- matrix(nrow = mrow,ncol = mcol) for(i in 1:nrow(outputs)){ for(j in 1:ncol(outputs)){ outputs[i,j] <- (i-1)*mrow + j } } inputs <- vector(\"list\",length=n) inp <- c() for(i in 1:n){ inputs[[i]] <- iris[i,1:veclength_n] for(j in 1:(ncol(iris)-1)){ inp <- c(inp,inputs[[i]][[j]]) } inputs[[i]] <- inp inp <- c() } weight_matrix <- generate_weights(veclength_n,m) inputs #weight_matrix #outputs min_dist <- 10000 min_ind <- 0 t <- 1 clusters = list() neighbour_radius <- 2 while(t < 25){ print(paste0(\"Iter no\",t)) if(t >= 1 && t <= 4) learning_rate <- 0.6 else if(t >= 5 && t <= 8){ learning_rate <- 0.5*learning_rate } else{ learning_rate <- 0.5*learning_rate } for(l in 1:length(inputs)){ print(paste0(\"Input no\",l)) print(nrow(weight_matrix)) for(w_ind in 1:nrow(weight_matrix)){ dist <- find_distance(weight_matrix[w_ind,],inputs[[l]]) #print(dist) if(dist < min_dist){ min_dist <- dist min_ind <- w_ind } } #print(min_dist) #print(min_ind) neighbours <- find_neighbours_within_radius(min_ind,neighbour_radius,mrow) top_neighbours <- c() left_neighbours <- c() right_neighbours <- c() bottom_neighbours <- c() i <- 1 while(i <= neighbour_radius){ top <- neighbours[[1]] + (i-1)*mrow #print(paste0(\"top\",top)) if(top < min_ind) top_neighbours <- c(top_neighbours,neighbours[[1]] + (i-1)*mrow) left <- neighbours[[2]] + (i-1) if(left < min_ind) left_neighbours <- c(left_neighbours,neighbours[[2]]+(i-1)) right <- neighbours[[3]] - (i-1) if(right > min_ind) right_neighbours <- c(right_neighbours,neighbours[[3]]-(i-1)) bottom <- neighbours[[4]] - (i-1)*mrow if(bottom > min_ind) bottom_neighbours <- c(bottom_neighbours,neighbours[[4]] - (i-1)*mrow) i <- i + 1 } i <- 1 weight_matrix[min_ind,] <- update_weights(weight_matrix[min_ind,],inputs[[l]],learning_rate) weight_matrix[top_neighbours,] <- update_weights(weight_matrix[top_neighbours,],inputs[[l]],learning_rate) weight_matrix[left_neighbours,] <- update_weights(weight_matrix[left_neighbours,],inputs[[l]],learning_rate) weight_matrix[right_neighbours,] <- update_weights(weight_matrix[right_neighbours,],inputs[[l]],learning_rate) weight_matrix[bottom_neighbours,] <- update_weights(weight_matrix[bottom_neighbours,],inputs[[l]],learning_rate) print(min_ind) if(t==24){ clusters <- append(clusters,min_ind) } min_dist <- 10000 } t <- t + 1 } #inputs clusters" 

@app.route("/rnn",methods=['POST','GET'])
def hellornn():
  return "sigma <- function(x){ return(1/(1+exp(-x))) } de_v <- function(o,out_o,out_s){ return((out_o - o)*(out_o*(1-out_o))*(out_s)) } de_w <- function(o,out_o,net_o,out_s,prev_out_s){ return((out_o-o)*(out_o)*(1-out_o)*(net_o)*(1-out_s)*(prev_out_s)) } n <- 3 w <- c(0.5,0.5) u <- c(1,1,1) v <- c(0.5,0.5,0.5) x <- c(0.2,0.3,0.2) o <- c(0.2,0.3,0.4) net_s <- vector(length=n) out_s <- vector(length=n) net_o <- vector(length=n) out_o <- vector(length=n) for(i in 1:length(x)){ if(i==1){ net_s[i] <- u[i]*x[i] out_s[i] <- sigma(net_s[i]) net_o[i] <- v[i]*out_s[i] out_o[i] <- sigma(net_o[i]) } else{ net_s[i] <- out_s[i-1]*w[i-1] + u[i]*x[i] out_s[i] <- sigma(net_s[i]) net_o[i] <- v[i]*out_s[i] out_o[i] <- sigma(net_o[i]) } } error <- (1/2)*sum((out_o-o)^2) i <- n while(i>0){ v[i] <- v[i] - v[i]*(de_v(o[i],out_o[i],out_s[i])) i <- i - 1 } i <- n while(i>1){ w[i-1] <- w[i-1] - w[i-1]*(de_w(o[i],out_o[i],net_o[i],out_s[i],out_s[i-1])) i <- i - 1 }"

@app.route("/art",methods=['POST','GET'])
def hellor():
  return "n = 4 m = 3 vigilence = 0.4 input = c(12,1,8,3) binary = list() size = n for(i in 1:length(input)){ a = rev(as.integer(intToBits(input[i]))) binary = c(binary,a[(length(a)- (n-1)) : length(a)]) } binary binary = matrix(binary,ncol = size,byrow = TRUE) bottom_up = matrix(rep(1/(size),size*m),ncol = m) bottom_up top_down = matrix(c(1),nrow = m,ncol = size) cluster = vector('list',length = m) for(i in 1:nrow(binary)){ a = as.matrix(binary[i,]) c1 = list() c2 = list() y = as.numeric(binary[i,]) %*% (bottom_up) print(paste0('y value is ',y)) count = length(which(max(y)==y)) k = 0 if(count == 1){ print('only one...') print(y) print(max(y)) k = which(max(y)==y) r_num = top_down[k,] %*% as.numeric(a) r_den = Reduce('+',a) r = r_num / r_den print(paste0('r value ',r)) if(r>vigilence){ x_num = Reduce('+',(top_down[k,] * as.numeric(a))) x_din = Reduce('+',a) x = x_num / x_din if(x>vigilence) { print(paste0('input ',i,' belongs to ',k)) cluster[[k]] = c(cluster[[k]],i) vk_new = top_down[k,] * as.numeric(a) top_down[k,] = vk_new print('updated top_down...') print(top_down) wk_new = vk_new / (0.5 + Reduce('+',vk_new)) bottom_up[,k] = wk_new print('updated bottom_up...') print(bottom_up) } } } else{ print('tie..') k = max(which(max(y)==y)) r_num = top_down[k,] %*% as.numeric(a) r_den = Reduce('+',a) r = r_num / r_den print(paste0('r num ',r_num,' r_din ',r_den)) if(r>vigilence){ x_num = Reduce('+',(top_down[k,] * as.numeric(a))) x_din = Reduce('+',a) x = x_num / x_din if(x>vigilence) { print(paste0('input ',i,' belongs to ',k)) cluster[[k]] = c(cluster[[k]],i) print(top_down[k,]) print(a) vk_new = top_down[k,] * as.numeric(a) top_down[k,] = vk_new print(paste0('v3_new ',vk_new)) print('updated top_down...') print(top_down) wk_new = vk_new / (0.5 + Reduce('+',vk_new)) bottom_up[,k] = wk_new print('updated bottom_up...') print(bottom_up) } } } }"
if __name__ == "__main__":
    app.run()